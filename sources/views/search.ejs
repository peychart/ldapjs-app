<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Recherche LDAP</title>
	<style>
		body {
			background: linear-gradient(to bottom, #ffffe0, #ffeb3b);
			font-family: Arial, sans-serif;
		}
		table {
			width: 100%;
			border-collapse: collapse;
			margin-top: 20px;
		}
		th, td {
			border: 1px solid #ddd;
			padding: 8px;
			text-align: left;
			cursor: pointer; /* Indique que les en-têtes sont cliquables */
		}
		th {
			background-color: #f2f2f2;
		}
		.empty-message {
			text-align: center;
			color: gray;
		}
		.header-buttons {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 20px;
		}
		.reset-button {
			margin-left: 10px;
		}
		button {
			padding: 8px 12px;
			border: none;
			border-radius: 4px;
			background-color: #D3D3D3; /* Couleur de fond */
			color: black;
			cursor: pointer;
		}
		button:hover {
			background-color: #C0C0C0; /* Couleur de fond */
		}
		input[type="text"] {
			padding: 8px;
			border-radius: 4px;
			border: 1px solid #ccc;
			width: 270px;
			background-color: #FFF5E0; /* Couleur orange plus clair */
		}
		.logout-button {
			margin-left: auto; /* Pour pousser le bouton à droite */
		}
		.dropdown {
			position: relative;
			display: inline-block;
			margin-left: 10px; /* Espacement à gauche */
		}
		.dropdown-content {
			display: none;
			position: absolute;
			background-color: #FFF5E0; /* Saumon atténué (plus clair) */
			border: 1px solid #ccc;
			z-index: 1;
			height: 400px; /* Hauteur maximale */
			min-height: 100px; /* Hauteur maximale */
			max-height: 1200px; /* Hauteur maximale */
			overflow-y: auto; /* Scroll si trop d'options */
			min-width: 300px; /* Largeur minimale */
			padding: 5px;
			resize: vertical; /* Permettre le redimensionnement vertical */
		}
		.dropdown-content label {
			display: block;
			padding: 8px;
			cursor: pointer;
			color: black; /* Couleur normale */
		}
		.dropdown-content label:hover {
			background-color: #f1f1f1; /* Changement de couleur au survol */
		}
		.show {
			display: block; /* Afficher le dropdown */
		}
		.checkboxes {
			display: flex;
			flex-direction: column;
		}
		.attributes-separator {
			height: 20px; /* Hauteur visible pour clic */
			background-color: #ccc; /* Couleur de fond */
			text-align: center;
			line-height: 20px; /* Centrer le texte */
			width: 100%; /* Largeur complète */
			border-top: 1px solid #aaa; /* Bordure en haut */
			margin-top: 5px;
		}
		/* Style pour le tooltip */
		.tooltip {
			position: relative;
			display: inline-block;
			cursor: pointer;
		}
		.tooltip .tooltiptext {
			visibility: hidden;
			width: 250px; /* Largeur du tooltip */
			background-color: #555; /* Couleur de fond du tooltip */
			color: #fff; /* Couleur du texte */
			text-align: center;
			border-radius: 6px;
			padding: 5px;
			position: absolute;
			z-index: 1;
			bottom: 125%; /* Positionnement au-dessus de l'élément */
			left: 50%;
			margin-left: -125px; /* Centrer le tooltip */
			opacity: 0; /* Commence caché */
			transition: opacity 0.3s; /* Transition pour l'apparition */
		}
		.tooltip:hover .tooltiptext {
			visibility: visible; /* Afficher le tooltip au survol */
			opacity: 1; /* Rendre visible */
		}
		.selected-profile {
			font-weight: bold; /* Profil sélectionné en gras */
			color: black; /* Afficher en noir */
		}
	</style>
</head>
<body>
	<h1>Recherche <span id="profileSpan"></span></h1>

	<div class="header-buttons">
		<form action="/search" method="post">
			<input type="hidden" id="selectedProfile" name="selectedProfile" value="<%= selectedProfile ?? '' %>">
			<input type="hidden" id="searchProfiles" name="searchProfiles" value="<%= JSON.stringify(searchProfiles) %>">
			<input type="text" id="searchTerm" name="searchTerm" placeholder="Recherche : (including  * ) ..." required value="<%= searchTerm ?? '' %>">
			<button type="button" onclick="searchSubmit(this.form)">Rechercher</button>
		</form>

		<form action="/searchDef" method="post" id="searchDefForm">
			<input type="hidden" id="newProfileName" name="newProfileName">
			<!-- Dropdown pour les objectClasses de TYPE STRUCTURAL avec tooltip -->
			<div class="dropdown tooltip">
				<button type="button" id="objectClassBtn">ObjectClasses</button>
				<span class="tooltiptext">Sélectionner les objectClasses objets de la recherche.</span>
				<div class="dropdown-content" height="300px;" id="objectClassDropdown">
					<div class="attributes-separator" onclick="updateProfileSpan('')">Profils de recherche</div>
					<div id="profilesContainer"></div>
					<div class="attributes-separator" onclick="createNewProfile()">Créer un nouveau profil</div>
					<div class="checkboxes" id="objectClassCheckboxes">
					<%	const sortedObjectClasses = ldapSchema.objectClasses
							.filter(objectClass => objectClass.TYPE === 'STRUCTURAL' || objectClass.TYPE === 'AUXILIARY')
							.sort((a, b) => a.NAME[0].localeCompare(b.NAME[0]));

						sortedObjectClasses.forEach(objectClass => { %>
							<label>
								<input type="checkbox" class="objectClassCheckbox" name="<%= objectClass.NAME[0] %>" value="<%= objectClass.NAME[0] %>">
								<%= objectClass.NAME[0] %>
							</label>
						<% }); %>
					</div>
				</div>
			</div>

			<!-- Dropdown pour les attributs MUST et MAY de l'objectClass sélectionné -->
			<div class="dropdown tooltip">
				<button type="button" id="attributesBtn" disabled>Attributes</button>
				<span class="tooltiptext" id="attributesTooltip">Sélectionner préalablement au moins un objectClass</span>
				<div class="dropdown-content" id="attributesDropdown" height="100px;" style="display: none;">
					<div class="attributes-separator">MUST attributes</div>
					<div class="checkboxes" id="mustAttributes"></div>
					<div class="attributes-separator">MAY attributes</div>
					<div class="checkboxes" id="mayAttributes"></div>
				</div>
			</div>
		</form>

		<div class="reset-button">
			<form action="/search" method="post">
				<button type="button" onclick="reload()">Effacer</button>
			</form>
		</div>

		<div class="logout-button">
			<form action="/logout" method="get">
				<button type="submit">Déconnexion</button>
			</form>
		</div>
	</div>

	<% if (error) { %>
		<p style="color: red;"><%= error %></p>
	<% } %>

	<h2>Résultats :</h2>
	<table>
		<thead>
			<tr>
				<th onclick="handleHeaderClick(this)">Action</th>
				<% if (results && results.length > 0) { %>
					<% 
						const keys = Object.keys(results[0]); 
					%>
					<% keys.forEach(key => { %>
						<th onclick="sortTableBy('<%= key %>')"><%= key %></th>
					<% }) %>
				<% } %>
			</tr>
		</thead>
		<tbody id="table-body">
			<% if (results && results.length > 0) { %>
				<% results.forEach(user => { %>
					<tr>
						<td>
							<button onclick="location.href='/newEdit/<%= user.dn %>'">Éditer</button>
						</td>
						<% 
							const keys = Object.keys(results[0]); 
							keys.forEach(key => {
						%>
							<td>
								<%= user[key] || 'N/A' %>
							</td>
						<% }) %>
					</tr>
				<% }) %>
			<% } else { %>
				<tr>
					<td colspan="<%= (results && results.length > 0) ? Object.keys(results[0]).length + 1 : 6 %>" class="empty-message">Aucun résultat trouvé.</td>
				</tr>
			<% } %>
		</tbody>
	</table>
<script>
const ldapSchema = <%- JSON.stringify(ldapSchema) %>;
const searchProfiles = JSON.parse(document.getElementById('searchProfiles').value);
let selectedAttributes = {}; // Objet pour stocker l'état des checkboxes

// Mettre le focus sur le champ de recherche lors du chargement de la page
window.onload = function() {
	document.getElementById("searchTerm").focus();
	populateProfiles(); // Appeler la fonction pour peupler les profils
};

function reload() {
	window.location.href = '/search';
}

// Fonction pour trier le tableau par un attribut donné
let sortOrder = {}; // Objet pour stocker l'ordre de tri de chaque colonne
function sortTableBy(attribute) {
	 const tbody = document.getElementById('table-body');
	const rows = Array.from(tbody.querySelectorAll('tr')); // Récupérer toutes les lignes du corps du tableau

	const headerRow = rows[0]; // La première ligne est l'en-tête  
	const dataRows = rows.slice(0); // Stocker uniquement les données 

	// Afficher le nombre de lignes récupérées 
	console.log(`Number of data rows (excluding header): ${dataRows.length}`);

	// Afficher le contenu des lignes avant le tri  
	dataRows.forEach((row, index) => {
		const cells = Array.from(row.querySelectorAll('td'));
		const cellValues = cells.map(cell => cell.innerText.trim());
		console.log(`Row ${index + 1}: `, cellValues);
	});

	// Changer l'ordre de tri pour cette colonne  
	sortOrder[attribute] = !sortOrder[attribute]; // Inverser l'ordre chaque fois que l'en-tête est cliqué

	// Tri des lignes de données  
	const sortedRows = [...dataRows].sort((a, b) => { // Crée une copie pour trier  
		const aValue = a.querySelector(`td:nth-child(${getColumnIndex(attribute)})`).innerText.trim();
		const bValue = b.querySelector(`td:nth-child(${getColumnIndex(attribute)})`).innerText.trim();

		// Vérifier si la colonne contient des nombres ou des dates  
		const isNumber = !isNaN(aValue) && !isNaN(bValue);
		const isDate = !isNaN(Date.parse(aValue)) && !isNaN(Date.parse(bValue));

		if (isNumber) {
			return sortOrder[attribute] ? aValue - bValue : bValue - aValue;
		} else if (isDate) {
			return sortOrder[attribute] ? new Date(aValue) - new Date(bValue) : new Date(bValue) - new Date(aValue);
		} else {
			return sortOrder[attribute] ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
		}
	});

	// Vider le tableau et réinsérer l'en-tête, puis les lignes triées  
	tbody.innerHTML = ''; // Vider le corps du tableau  
	tbody.appendChild(headerRow); // Réinsérer l'en-tête  
	sortedRows.forEach(row => tbody.appendChild(row)); // Ajouter les lignes triées  
}

// Fonction pour obtenir l'index de la colonne correspondante à un attribut
function getColumnIndex(attribute) {
	const headerCells = document.querySelectorAll('thead th');
	for (let i = 1; i < headerCells.length; i++) { // Commencer à 1 pour ignorer la première colonne "Action"
		if (headerCells[i].innerText === attribute) {
			return i + 1; // +1 pour tenir compte de la colonne d'action  
	}	}
	return -1; // Retourne -1 si l'attribut n'est pas trouvé  
}

// Fonction pour peupler les profils enregistrés
function populateProfiles() {
	const profilesContainer = document.getElementById('profilesContainer');
	profilesContainer.innerHTML = ''; // Vider le conteneur avant de le remplir
	const profiles = Object.keys(searchProfiles);

	if (profiles.length === 0) {
		profilesContainer.innerHTML = '<label class="profils" style="color: grey;">Aucun profil encore enregistré ...</label>';
	} else {
		profiles.forEach(profile => {
			const profileLink = document.createElement('div');
			profileLink.classList.add('profils');
			profileLink.style.display = 'flex'; // Activer flexbox
			profileLink.style.justifyContent = 'space-between'; // Justifier le contenu
			profileLink.style.alignItems = 'center'; // Centrer verticalement
			profileLink.style.marginBottom = '5px'; // Ajout d'un espacement entre les profils

			// Créer le contenu du profil avec un bouton de suppression
			profileLink.innerHTML = `<span class="profile-item" id="${profile}" style="color: black;">- ${profile}</span><button class="remove-profile" type="button" style="color: red; border: 1px solid grey; cursor: pointer; margin-left: 10px; border-radius: 4px; padding: 2px 5px;" title="Suppression du profil"><b>x</b></button>`;

			// Écouter le clic sur le profil pour le sélectionner
			profileLink.addEventListener('click', () => selectProfile(profile));

			// Ajouter l'événement au bouton de suppression
			const removeButton = profileLink.querySelector('.remove-profile');
			removeButton.addEventListener('click', (event) => {
				event.stopPropagation(); // Empêche la propagation du clic au parent
				removeProfil(profile);
			});

			profilesContainer.appendChild(profileLink);
		});
		selectProfile(document.getElementById("selectedProfile").value);
}	}

function removeProfil(profile) {
	// Logique pour supprimer le profil
	if (!confirm(`Êtes-vous sûr de vouloir supprimer le profil : ${profile} ?`))
		return false;

	// Effacement du profil
	updateProfileSpan(profile);
	document.getElementById('newProfileName').value = profile;
	document.getElementById("searchDefForm").submit();
}

function updateProfileSpan(profile) {
	const previousSelectedProfile = document.getElementById("selectedProfile").value;
	document.getElementById("selectedProfile").value = profile;
	document.getElementById("profileSpan").textContent = profile ?'de "' + profile + '" :' :'';
	if (previousSelectedProfile.length) {	// dé-select l'ancien profil sélectionné
		// Réinitialiser les checkboxes avant de mettre à jour éventuelle
		resetObjectClassesAndAttributes();
		document.getElementById(previousSelectedProfile).classList.remove('selected-profile');
}	}

function selectProfile(newProfile) {
	// Vérifier que ce profil existe
	const selectedProfileData = newProfile ? searchProfiles[newProfile] ?? {} :{};
	if (!Object.keys(selectedProfileData).length)
		newProfile = '';

	updateProfileSpan(newProfile);

	if (newProfile) { // Mettre à jour les objectClasses et attributs en fonction du profil sélectionné
		document.getElementById(newProfile)?.classList.add('selected-profile'); // Marquer la nouvelle sélection

		// Sélecter la liste des objectClasses du profil retenu
		selectedProfileData.objectClasses.forEach(objectClass => {
			const checkbox = document.querySelector(`.objectClassCheckbox[value="${objectClass}"]`);
			if (checkbox) {
				checkbox.checked = true; // Cocher l'objectClass
				checkbox.dispatchEvent(new Event('change')); // Déclencher l'événement de changement
			}
		});

		// Sélecter la liste des attributes du profil retenu
		const mustAttributesDiv = document.getElementById("mustAttributes");
		const mayAttributesDiv  = document.getElementById("mayAttributes");
		selectedProfileData.attributes.forEach(attribute => {
			const checkbox = mustAttributesDiv.querySelector(`#must-${attribute}`) || mayAttributesDiv.querySelector(`#may-${attribute}`);
			if (checkbox) {
				checkbox.checked = true; // Cocher l'objectClass
				checkbox.dispatchEvent(new Event('change')); // Déclencher l'événement de changement
			}
		});
	}
	setTimeout(() => {document.getElementById("attributesDropdown").style.display = 'none'}, 1000);
}

function checkSameProfileExist(selectedObjectClasses) { // Vérification parmi les profiles existants
 	// Créer une fonction pour comparer deux tableaux
	const arraysAreEqual = (arr1, arr2) => {
		if (arr1.length !== arr2.length) return false;
		const set1 = new Set(arr1);
		const set2 = new Set(arr2);
		for (const item of set1)
			if (!set2.has(item)) return false;
		return true;
	};

	// Parcourt chaque profil dans searchProfiles
	for (const profileName in searchProfiles) {
		const profileObjectClasses = searchProfiles[profileName].objectClasses;

		// Vérifie si les objectClasses sélectionnés sont strictement les mêmes que ceux du profil à créer
		if (arraysAreEqual(selectedObjectClasses, profileObjectClasses)) {
			return profileName; // Un profil similaire a été trouvé
	}	}

	return null; // Aucun profil similaire n'a été trouvé
}

function checkSelectionsNewProfile() { // Vérifier les sélections requises à la création d'un nouveau profil
	const objectClassCheckboxes = document.querySelectorAll('#objectClassCheckboxes .objectClassCheckbox');
	const mustAttributes = document.querySelectorAll('#mustAttributes input[type="checkbox"]');
	const mayAttributes = document.querySelectorAll('#mayAttributes input[type="checkbox"]');

	// Vérifier si au moins une checkbox est cochée dans objectClassCheckboxes
	const isAnyObjectClassChecked = Array.from(objectClassCheckboxes).some(checkbox => checkbox.checked);

	// Vérifier si au moins une checkbox est cochée dans mustAttributes ou mayAttributes
	const isAnyMustChecked = Array.from(mustAttributes).some(checkbox => checkbox.checked);
	const isAnyMayChecked = Array.from(mayAttributes).some(checkbox => checkbox.checked);

	return isAnyObjectClassChecked && (isAnyMustChecked || isAnyMayChecked);
}

function createNewProfile() {
	if (!checkSelectionsNewProfile()) {
		alert("Il faut prélablement définir ce nouveau profile !...\n (selectionner au moins un objectClass et un attribut de recherche)");
		return;
	}

	let myProfile = document.getElementById("selectedProfile").value;
	if (myProfile && !confirm(`Vous allez modifier le profil actuellement sélectionné : "${myProfile}" ...\n(Remarque: si vous souhaitez désélectionner le profil actuel, cliquer sur "Profils de recherche")`)) {
		 myProfile = '';
	}
	if (!myProfile)
		myProfile = prompt("Nom d'un nouveau profil :");

	if (myProfile) {
		const selectedObjectClasses = Array.from(document.querySelectorAll('#objectClassCheckboxes .objectClassCheckbox:checked')).map(checkbox => checkbox.value);
		const similarProfile = checkSameProfileExist(selectedObjectClasses);
		if (similarProfile) {
			alert("Un profil identique existe déjà : " + similarProfile);
			return; // Stoppe l'exécution si un profil similaire est trouvé
		}

		// Vérifie si un profil de même nom existe déjà
		let existingProfileName = null;
		for (const profileName in searchProfiles) {
			if (profileName.toLowerCase() === myProfile.toLowerCase()) {
				existingProfileName = profileName; // Conserver le nom d'origine pour l'affichage
				break;
		}	}

		if (existingProfileName &&
			!confirm("Le profil de nom '" + existingProfileName + "' existe déjà !\nEtes-vous sûr de vouloir le remplacer ?")) {
			return; // Exit si l'utilisateur ne souhaite pas remplacer
		}

		// Soumission du formulaire de création de profil
		document.getElementById('newProfileName').value = myProfile;

		document.getElementById("searchDefForm").submit();
	}
}

// Fonction pour réinitialiser les checkboxes
function resetObjectClassesAndAttributes() {
	const objectClassCheckboxes = document.querySelectorAll('.objectClassCheckbox');
	const mustAttributesDiv = document.getElementById("mustAttributes");
	const mayAttributesDiv = document.getElementById("mayAttributes");
	mustAttributesDiv.innerHTML = ''; // Réinitialiser les options MUST
	mayAttributesDiv.innerHTML = ''; // Réinitialiser les options MAY

	// Réinitialiser et désélectionner les checkboxes des objectClasses
	objectClassCheckboxes.forEach(checkbox => {
		checkbox.checked = false; // Désélectionner toutes les checkboxes
	});

	// Masquer le dropdown des attributs
	const attributesDropdown = document.getElementById("attributesDropdown");
	attributesDropdown.style.display = 'none'; // Masquer le dropdown
}

// Gérer la sélection/dé-sélection d'objectClasses
document.querySelectorAll('.objectClassCheckbox').forEach(checkbox => {
	checkbox.addEventListener("change", function() {
		const mustAttributesDiv = document.getElementById("mustAttributes");
		const mayAttributesDiv = document.getElementById("mayAttributes");
		mustAttributesDiv.innerHTML = ''; // Réinitialiser les options MUST
		mayAttributesDiv.innerHTML = ''; // Réinitialiser les options MAY
		const attributesDropdown = document.getElementById("attributesDropdown");
		attributesDropdown.style.display = 'none'; // Masquer le dropdown

		// Récupérer tous les objectClasses sélectionnés
		const selectedObjectClasses = Array.from(document.querySelectorAll('.objectClassCheckbox:checked'))
			.map(cb => cb.value);

		// Mettre à jour le tooltip des attributs
		const attributesTooltip = document.getElementById("attributesTooltip");
		attributesTooltip.textContent = selectedObjectClasses.length > 0
			? "Sélectionner les attributs objets de la recherche"
			: "Sélectionner préalablement au moins un objectClass"; // Texte par défaut

		// Utiliser des ensembles pour éviter les doublons
		const seenMustAttributes = new Set(); // Pour les attributs MUST
		const seenMayAttributes = new Set(); // Pour les attributs MAY

		// Ajouter aux sets les valeurs des nouveaux attributs de l'objectClass sélectionné
		selectedObjectClasses.forEach(selectedClass => {
			const obj = ldapSchema.objectClasses.find(cls => cls.NAME[0] === selectedClass);
			if (obj) {
				// Ajout des SUP attributes
				const objectClass = setInheritedMustAttributes(ldapSchema, obj);

				// Ajouter les attributs MUST
				if (objectClass.MUST && objectClass.MUST.length > 0) {
					objectClass.MUST.forEach(attribute => {
						seenMustAttributes.add(attribute); // Ajouter à l'ensemble des MUST
					});
				}
				// Ajouter les attributs MAY
				if (objectClass.MAY && objectClass.MAY.length > 0) {
					objectClass.MAY.forEach(attribute => {
						seenMayAttributes.add(attribute); // Ajouter des MAY à son SET
					});
				}
			}
		});

		// Deuxième étape : Retirer les attributs MUST du set des MAY
		seenMustAttributes.forEach(attribute => {seenMayAttributes.delete(attribute);});

		// Troisième étape : Mettre à jour les checkboxes à partir des sets
		// Générer les checkboxes pour MUST
		seenMustAttributes.forEach(attribute => {
			const checkboxId = `must-${attribute}`;
			const checkboxDiv = document.createElement("div");
			const isChecked = selectedAttributes[attribute] || false; // Vérifier l'état enregistré
			checkboxDiv.innerHTML = `<label><input type="checkbox" id="${checkboxId}" name="${checkboxId}" value="${attribute}" ${isChecked ? 'checked' : ''}> ${attribute}</label>`;
			mustAttributesDiv.appendChild(checkboxDiv);
			// Enregistrer l'état du checkbox
			document.getElementById(checkboxId).addEventListener('change', function() {
				selectedAttributes[attribute] = this.checked; // Mettre à jour l'état
			});
		});

		// Générer les checkboxes pour MAY
		seenMayAttributes.forEach(attribute => {
			const checkboxId = `may-${attribute}`;
			const checkboxDiv = document.createElement("div");
			const isChecked = selectedAttributes[attribute] || false; // Vérifier l'état enregistré
			checkboxDiv.innerHTML = `<label><input type="checkbox" id="${checkboxId}" name="${checkboxId}" value="${attribute}" ${isChecked ? 'checked' : ''}> ${attribute}</label>`;
			mayAttributesDiv.appendChild(checkboxDiv);
			// Enregistrer l'état du checkbox
			document.getElementById(checkboxId).addEventListener('change', function() {
				selectedAttributes[attribute] = this.checked; // Mettre à jour l'état
			});
		});

		// Afficher le dropdown des attributs si au moins un objectClass est sélectionné
		if (selectedObjectClasses.length > 0) {
			attributesDropdown.style.display = objectClassDropdown.classList.contains("show") ?'block' :'none'; // Afficher le dropdown des attributs
			document.getElementById("attributesBtn").disabled = false; // Activer le bouton
		} else {
			document.getElementById("attributesBtn").disabled = true; // Désactiver le bouton si aucun objectClass sélectionné
		}
	});
});

// Récupération de la définition complète d'un objectClass dans le schema de la base
function getObjectClassByName(ldapSchema, name) {
	const objectClass = ldapSchema.objectClasses.find(schema => schema.NAME.includes(name));
	return objectClass ? objectClass : null;
}

// Ajouter tous les attributs MUST hérités
function setInheritedMustAttributes(ldapSchema, objectClass) {
	if (!objectClass || typeof objectClass !== 'object') {
		throw new Error('Invalid objectClass provided');
	}

	const setInheritedMustAttributesFromSuperClasses = (cls) => {
		 let results = [...(cls.MUST || [])]; // Initialiser avec les attributs MUST actuels sous forme de tableau

		if (cls.SUP && cls.SUP !== 'top') {
			const supClass = getObjectClassByName(ldapSchema, cls.SUP);
			if (supClass) {
				const supMustAttributes = setInheritedMustAttributesFromSuperClasses(supClass);
				results = Array.from(new Set([...results, ...supMustAttributes]));
			}
		}
		return results; // Retourner le tableau des attributs MUST
	};

	return {
		...objectClass,
		MUST: setInheritedMustAttributesFromSuperClasses(objectClass)
	};
}


function searchSubmit(form) {
	if (!document.getElementById('searchTerm').value.length) {
		alert("Saisir une valeur de recherche ...");
		return false;
	}
	if (!document.getElementById("selectedProfile").value){
		alert("Sélectionner préalablement un profil de recherche !...\n(ObjectClasses et Attributes de recherche)");
		return false;
	}
	form.submit();
}

// Afficher/Masquer le dropdown des objectClasses
document.getElementById("objectClassBtn").addEventListener("click", function() {
	const objectClassDropdown = document.getElementById("objectClassDropdown");
	objectClassDropdown.classList.toggle("show");

	// Fermer aussi les attributs lorsqu'on ferme les objectClasses
	if(!objectClassDropdown.classList.contains("show"))
		document.getElementById("attributesDropdown").style.display = 'none';
});

// Afficher/Masquer le dropdown des attributs MUST
document.getElementById("attributesBtn").addEventListener("click", function() {
	const attributesDropdown = document.getElementById("attributesDropdown");
	attributesDropdown.style.display = (objectClassDropdown.classList.contains("show") && attributesDropdown.style.display === 'block') ?'none' :'block';
});

// Fermer le dropdown si on clique en dehors
window.addEventListener('click', function(event) {
	const objectClassDropdown = document.getElementById("objectClassDropdown");
	const attributesDropdown = document.getElementById("attributesDropdown");

	// Vérifier si le clic est en dehors des dropdowns
	if (!event.target.matches('#objectClassBtn') && !event.target.matches('#attributesBtn') &&
		!objectClassDropdown.contains(event.target) && !attributesDropdown.contains(event.target)) {
		objectClassDropdown.classList.remove('show');
		attributesDropdown.style.display = 'none'; // Fermer le dropdown des attributs
	}
});

document.getElementById("searchTerm").addEventListener("focus", function() {
	this.select();
});
</script>
</body>
</html>
