/*	LDAP-editor (Version 0.1 - 2022/06)
	<https://github.com/peychart/croncpp>

	Copyright (C) 2022  -  peychart

	This program is free software: you can redistribute it and/or
	modify it under the terms of the GNU General Public License as
	published by the Free Software Foundation, either version 3 of
	the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty
	of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
	See the GNU General Public License for more details.

	You should have received a copy of the GNU General Public
	License along with this program.
	If not, see <http://www.gnu.org/licenses/>.

	Details of this licence are available online under:
						http://www.gnu.org/licenses/gpl-3.0.html
*/
const express = require('express');
const ldap = require('ldapjs');
const path = require('path');
//const configPath = path.join(__dirname, 'config.json');
const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const session = require('express-session');
const passport = require('passport');
const { Strategy: LdapStrategy } = require('passport-ldapauth');
//const winston = require('winston');
//const createLogger = require('./utils/log');
const { createLogger, format, transports } = require('winston');
const {
	bindClient,
	searchLDAP,
	rawSearchLDAP,
	loadSchema,
	loadAttributesConfig,
	getUserRoleFromDatabase,
	getAllSupObjectClasses,
	setInheritedMustAttributes,
	enrichObjectClassWithAttributes,
	getObjectClassByName,
	getObjectClassesByType,
	updateLDAP,
	updateAPPConfig
} = require('./utils/ldapUtils');
const {
	loadConfig
} = require('./utils/ldapConfig');
const {
	isEqual
} = require('./utils/utils');

const app = express();
let config;

// Chargement initial de la configuration
(async () => {
	// Chargement initial de la configuration
	const logger = createLogger({
level: 'error', // 'info' Niveau de log par défaut
	format: format.combine(
		format.timestamp(),
		format.json()
	),
	transports: [
		new transports.Console(), // Journalisation dans la console
		new transports.File({ filename: 'error.log', level: 'error' }), // Journalisation des erreurs dans un fichier
	],
});
	config = loadConfig();

	try {
		// Récupération du schéma LDAP
		const ldapSchema = await loadSchema(ldap, config);
//console.log('ldapSchema: ', JSON.stringify(ldapSchema, null, 2));	// Pour debug
		let attributesConfig = await loadAttributesConfig(config);
//console.log('attributesConfig: ', JSON.stringify(attributesConfig, null, 2)); // Display for debug

		// Configuration des middlewares
		app.use(bodyParser.json()); // Pour traiter les JSON
		app.use(bodyParser.urlencoded({ extended: true })); // Pour parser les données de formulaire
		app.use(cookieParser());

		app.use(session({
			secret: config.sessionSecret,
			resave: false,
			saveUninitialized: true,
			cookie: { maxAge: 4 * 60 * 60 * 1000 } // Durée de vie du cookie de session
		}));

		// Initialisation de Passport
		app.use(passport.initialize());
		app.use(passport.session());

		app.use('/js', express.static(path.join(__dirname, 'public/js')));
		app.set('view engine', 'ejs');

		// Middleware de journalisation des actions
		app.use((req, res, next) => {
			const user = req.session.user ? req.session.user : { dn: 'Anonyme', role: 'Invité' }; // Valeurs par défaut pour les utilisateurs non authentifiés
			const logMessage = {
				userDn: user.dn, // Distinguished Name de l'utilisateur
				userRole: user.role, // Rôle de l'utilisateur
				path: req.path, // Chemin de la requête
				method: req.method, // Méthode de la requête
				time: new Date().toISOString() // Heure de la requête
			};

			// Journaliser le message
			logger.info(logMessage);
			next();
		});

		// Fin de la configuration initiale
		logger.info('Application démarrée avec succès.');

		// ****************************************************************************
		// *********************** DEFINITION DES ROUTES ******************************

		// ***********************************************************
		// Route pour le masque de connexion
		app.get('/', (req, res) => {
			// Lire les cookies pour obtenir les données précédentes
			const login = req.cookies.login || ''; // Lire le DN du cookie, s'il existe

			// Rendre la vue de connexion avec le login précédent
			res.render('login', { login, error: null, ldapUrl: `${config.ldap.url}:${config.ldap.port}` });
		});

		// ***********************************************************
		// Route pour traiter la soumission du formulaire de connexion
		app.post('/login', async (req, res) => {
			const { login, password } = req.body; // Récupération du login et du mot de passe
			const appClient = ldap.createClient({ url: `${config.ldap.url}:${config.ldap.port}` });
			let client;

			try {
				// Créer un client LDAP
				await bindClient(appClient, config.ldap.data.bindDN, config.ldap.data.bindPassword);

				// Définir les attributs à rechercher
				const attributesToSearch = ['uid', 'mail', 'employeeNumber', 'sn', 'givenName', 'cn'];

				const searchPromises = attributesToSearch.map(attr => {
					const searchOptions = {
						filter: `(${attr}=${login})`, // Filtrer par chaque attribut
						scope: 'sub',
						attributes: ['dn'], // N'inclure que le DN dans le résultat
						sizeLimit: 15
					};

					return rawSearchLDAP(appClient, config.ldap.data.baseDN, searchOptions).catch(err => {
						return []; // Retourner un tableau vide en cas d'erreur
					});;
				});

				// Attendre que toutes les recherches soient terminées
				const searchResults = await Promise.all(searchPromises);

				// Filtrer les résultats pour obtenir le DN : extraire objectName pour le dn ...
				const validResults = searchResults.flat().map(result => result.objectName).filter(dn => dn);

				// Vérifier si une entrée a été trouvée
				if (validResults.length === 0) {
					throw new Error('Nom d\'utilisateur ou mot de passe incorrect.');
				} else if (validResults.length > 1) {
					const allEqual = validResults.every(dn => dn === validResults[0]);
					if (!allEqual) {
						throw new Error('Plus d\'une occurrence d\'identifiant trouvée ! Veuillez préciser davantage votre login.');
					}
				}

				// Extraire le DN de l'utilisateur à partir du résultat de la recherche
				const bindDN = validResults[0]; // Récupérer le DN de la première entrée

				// Tenter de se connecter au serveur LDAP avec le DN récupéré
				client = ldap.createClient({ url: `${config.ldap.url}:${config.ldap.port}` });
				await bindClient(client, bindDN, password);

				// Authentification réussie, récupérer le rôle de l'utilisateur
				const role = await getUserRoleFromDatabase(bindDN); // Utiliser le DN récupéré

				// Stocker les informations de l'utilisateur dans la session
				req.session.user = {
					dn: bindDN,
					role
				};

				// Authentification de l'application réussie
				req.session.appClient = appClient;

				// Mémoriser le dernier login dans un cookie
				res.cookie('login', login, { maxAge: 24 * 60 * 60 * 1000 }); // Expire dans 1 jour

				// Rediriger vers la page d'accueil
				return res.redirect('/search');

			} catch(err) {
				// Gestion des erreurs : ne pas afficher d'erreur dans la console
				return res.render('login', {
					login: login, // Garder la valeur du login pré-rempli
					error: err.message || 'Nom d\'utilisateur ou mot de passe incorrect.',
				ldapUrl: `${config.ldap.url}:${config.ldap.port}`
				});
			} finally {
				// S'assurer que le client LDAP est déconnecté
			if (client)
				client.unbind();
				appClient.unbind();
			}
		});

		// ***********************************************************
		// Route de déconnexion
		app.get('/logout', (req, res) => {
			// Libérer le client de l'application
			if (req.session.appClient) {
				req.session.appClient.unbind((err) => {
					if (err) {
						console.error('Erreur lors de la déconnexion du client LDAP de l\'application:', err);
					}
				});
			}

			req.session.destroy((err) => {
				if (err) {
					console.error('Erreur lors de la destruction de la session:', err);
				}
				return res.redirect('/'); // Rediriger vers la page de connexion
			});
		});

		// ***********************************************************
		// Route de recherche (GET)
		app.get('/search', async (req, res) => {

			// Créer un client LDAP
			const client = ldap.createClient({ url: `${config.ldap.url}:${config.ldap.port}` });

			const opts = {
				filter: `(objectClass=applicationProcess)`,
				scope: 'sub',
				attributes: ['cn', 'ou', 'l']
			};
			const rootDn = (config.configDn.searchProfiles ?? 'ou=searchProfile') + ',' + config.configDn.root;

			try {
				await bindClient(client, config.ldap.data.bindDN, config.ldap.data.bindPassword);

				// Récupérer les résultats de la recherche LDAP
				const searchProfiles = await searchLDAP(client, rootDn, opts).catch(() => {
					return []; // Retourner un tableau vide en cas d'erreur
				});

				//const profilesToRender = searchProfiles.length > 0 ?searchProfiles :searchProfiles_exemple;
				const profilesToRender = {};
				searchProfiles.forEach(profile => {
					const name = profile.cn[0]; // Récupérer le nom de l'entrée
					profilesToRender[name] = {
						objectClasses: profile.ou, // Utiliser 'ou' pour les classes d'objet
						attributes: profile.l // Utiliser 'l' pour les attributs
					};
				});

				// Lire les cookies pour obtenir les données précédentes
				const selectedProfile = req.cookies.selectedProfile
					?(Object.keys(profilesToRender).includes(req.cookies.selectedProfile)
						?req.cookies.selectedProfile
						:'')
					:'';

				// Rendre la vue de recherche
				res.render('search', { results: null, searchTerm: req.body.searchTerm, ldapSchema, searchProfiles: profilesToRender, selectedProfile, error: null });
			} catch(error) {
					console.error('Erreur:', error);
				if (client) {
					client.unbind(); // Assurez-vous que le client est délié
				}
				// Passer l'erreur à la vue avec un statut 500 (Erreur interne du serveur)
				return res.status(500).render('search', { results: null, searchTerm: null, ldapSchema, attributesConfig, searchProfiles: profilesToRender, selectedProfile, error: error.message });
			} finally {
				// Déconnexion du client principal
				if (client) {
					try {
						await client.unbind();
					} catch(unbindError) {
						console.error('Erreur lors de la déconnexion du client:', unbindError);
				}	}
			}
		});

		// ***********************************************************
		// Route de recherche (POST)
		app.post('/search', async (req, res) => {
			const searchTerm = req.body.searchTerm;
			const selectedProfile = req.body.selectedProfile;
			const searchProfiles = JSON.parse(req.body.searchProfiles);
			const profile = searchProfiles[selectedProfile];

			// Mémoriser le dernier login dans un cookie
			res.cookie('selectedProfile', selectedProfile, { maxAge: 24 * 60 * 60 * 1000 }); // Expire dans 1 jour

			// Créer un client LDAP
			const client = ldap.createClient({ url: `${config.ldap.url}:${config.ldap.port}` });

			try {
				if (!profile || Object.keys(profile).length === 0)
				 	throw new Error('Aucun profile de recherche sélectionné !...');

				// Fonction de recherche de tous les noms d'un attribut
				const getAllAttributeNames = function(attrName) {
					for (const attribute of ldapSchema.attributes) {
						if (attribute.NAME.includes(attrName)) {
							// Retourne tous les autres noms sauf celui donné
							return attribute.NAME;
					}	}
					return []; // Si non trouvé, retourne un tableau vide
				};

				// Ajout des sysnonymes de noms d'attributs au profil
				const allNames = new Set();
				profile.attributes.forEach(attr => {
					getAllAttributeNames(attr).forEach(name => allNames.add(name));
				});
				profile.attributes = Array.from(allNames);

				// Construire les options de recherche
				const objectClassFilter = profile.objectClasses.map(cls => `(objectClass=${cls})`).join('');
				const attributeFilters = profile.attributes.map(attr => `(${attr}=${searchTerm})`).join('');
				const filter = `(&${objectClassFilter}(|${attributeFilters}))`;
				const opts = {
					filter: filter,
					scope: 'sub',
					attributes: ['dn', ...profile.attributes]
				};

				await bindClient(client, config.ldap.data.bindDN, config.ldap.data.bindPassword);

				// Récupérer les résultats de la recherche LDAP
				const results = await searchLDAP(client, config.ldap.data.baseDN, opts);

				// Ajout des attributs manquants
				results.forEach(result => {
					opts.attributes.forEach(attribute => {
						if (!result.hasOwnProperty(attribute)) {
							result[attribute] = []; // Ajouter l'attribut avec la valeur 'N/A'
						}
					});
				});

				// Suppression des attributs synonymes
				results.forEach(result => {
					Object.keys(result).forEach(attrName => {
						const attribute = ldapSchema.attributes.find(item => item.NAME.some(name => name === attrName));
						if (attribute) {
							const primaryAttrName = attribute.NAME[0];
							for (let i = attribute.NAME.length - 1; i >= 0; i--) {
								const name = attribute.NAME[i];
								if (name !== primaryAttrName) {
									if (result[name] && result[name].length) {
										result[primaryAttrName] = result[name];
									}
									delete result[name];
						}	}	}
					});
				});

				// Passer le searchTerm à la vue avec un statut 200 (OK)
				return res.status(200).render('search', { results, searchTerm: req.body.searchTerm, ldapSchema, attributesConfig, searchProfiles, selectedProfile, error: null });

			} catch(error) {
					console.error('Erreur:', error);
				if (client) {
					client.unbind(); // Assurez-vous que le client est délié
				}
				// Passer l'erreur à la vue avec un statut 500 (Erreur interne du serveur)
				return res.status(500).redirect('search', { error: error.message });
			} finally {
				// Déconnexion du client principal
				if (client) {
					try {
						await client.unbind();
					} catch(unbindError) {
						console.error('Erreur lors de la déconnexion du client:', unbindError);
				}	}
			}
		});

		// Route de définition des recherches (POST)
		app.post('/searchDef', async (req, res) => {
			// Déclaration du client de connexion
			const client = ldap.createClient({ url: `${config.ldap.url}:${config.ldap.port}` });

			let dn = req.params.dn; // Assignation de dn depuis les paramètres de l'URL;
			let attrName = null; // Initialisation pour le nom de l'attribut
			let entry = { objectClass: ['top', 'applicationProcess'] };

			try {
				// Connexion au serveur LDAP
				await bindClient(client, config.ldap.data.bindDN, config.ldap.data.bindPassword);

				// Récupérer les clés du corps de la requête
				const keys = Object.keys(req.body);

				const rootDn = (config.configDn.searchProfiles ?? 'ou=searchProfile') + ',' + config.configDn.root;

				for (let key of keys) {
					if (key.startsWith('must-') || key.startsWith('may-')) {
						if (!entry.l) entry.l = [];
						entry.l.push(req.body[key]);
					} else if (key !== 'newProfileName') {
						if (!entry.ou) entry.ou = [];
						entry.ou.push(req.body[key]);
				}	}
				entry.cn = req.body.newProfileName;

				// Validation des données
				if (!req.body.newProfileName) {
					return res.status(400).send('Données manquantes dans \'/search/:dn\'.');
				}

				// Mise à jour dans la base LDAP
				await updateAPPConfig(client, 'cn=' + req.body.newProfileName, rootDn, entry);

				return res.redirect('search');
				//return res.redirect(`/newEdit/${dn}?errMsg=${encodeURIComponent(req.session.edit?.errMsg || '')}`);

			} catch(error) {
				console.error('Erreur:', error);
				res.status(500).send({ message: 'Erreur lors de la mise à jour de l\'attribut', error: error.message });
			} finally {
				// Déconnexion du client LDAP
				if (client) {
					client.unbind();
			}	}
		});

		/* *****************************
		 * Route d'édition de l'oject dn
		 */
		app.get('/newEdit/:dn', async (req, res) => {
			const dn = req.params.dn;
			delete req.session.edit;

			return res.redirect(`/edit/${dn}`);
			//return res.redirect(`/edit/${dn}`);
		});

		app.get('/edit/:dn', async (req, res) => {
			const dn = req.params.dn; // Récupérer le DN des paramètres de l'URL
			const client = ldap.createClient({ url: `${config.ldap.url}:${config.ldap.port}` });

			try {let objectData;

				// Liaison au client LDAP
				await bindClient(client, config.ldap.data.bindDN, config.ldap.data.bindPassword);

				// Récupération des Data à éditer
				objectData = req.session.edit?.objectData;

//console.clear(); console.log('\nreq.session.edit: ', req.session.edit);	// Pour debug

				if (!objectData) {
					const options = {
						scope: 'base', // Recherche unique sur le DN spécifié
						attributes: ['*'] // Attributs à récupérer
					};

					// Récupration de l'entrée dn à éditer
					objectData = (await searchLDAP(client, dn, options)
						.catch(() => {
							throw new Error(`Objet ${dn} non trouvé`); // Lancer une erreur vers le catch
						})
					)[0];
				}

//console.clear(); console.log('objectData: ', JSON.stringify(objectData, null, 2)); // Display for debug

				// On élimie l'objectClass === 'top'
				let objectClassesToSearch = [
					...(objectData?.objectClass.filter(item => item !== 'top') || []),
					...(req.session.edit?.ADDED || [])
				]; if (!objectClassesToSearch.length)
					throw new Error('DN à éditer vide: création ?...');

				// Ajout des objectClasses SUP (excluding 'top')
				const addSupObjectClasses = (ldapSchema, objectClassesToSearch) => {
					const allSupClasses = new Set(); // Utiliser un Set pour éviter les doublons
					for (const objClass of objectClassesToSearch) {
						const supClasses = getAllSupObjectClasses(ldapSchema, objClass);
						supClasses.forEach(supClass => allSupClasses.add(supClass));
					}
					return Array.from(allSupClasses);
				};
				objectClassesToSearch = [...new Set([...objectClassesToSearch, ...addSupObjectClasses(ldapSchema, objectClassesToSearch)])];

				// Récupérer la définition de chaque objectClass composant notre dn à éditer
				const objectClassesDetails = objectClassesToSearch.map(objectClassName => {
					try {
						const cls = getObjectClassByName(ldapSchema, objectClassName);
						const objCls = setInheritedMustAttributes(ldapSchema, cls);
						return enrichObjectClassWithAttributes(ldapSchema, objCls);
					} catch(error) {
						console.error(`Erreur lors de la récupération de ${objectClassName} :`, error);
						return null; // Ou une valeur par défaut, si nécessaire
					}
				});

				// Ajouter la propriété ADDED/DELETED=true aux objectClasses éventuellement concernés
				['ADDED', 'DELETED'].forEach(type => {
					objectClassesDetails.forEach(objCls => {
						if (req.session.edit?.[type])
							if (req.session.edit[type].includes(objCls.NAME[0])) objCls[type]=true;
					});
					if (req.session.edit?.[type]) delete req.session.edit[type];
				});

//console.clear(); console.log('objectClassesDetails: ', JSON.stringify(objectClassesDetails, null, 2)); // Display for debug

				// Enrich chaque objectClass du dn courant avec les data d'objectData et d'attributesConfig
				//		1: avec les éventuelles customConf d'attributs définies dans attributesConfig
				objectClassesDetails.forEach(objectClass => {
					// Parcours des attributs de MUST et MAY
					['MUST', 'MAY'].forEach(key => {
						objectClass[key].forEach(currentAttr => {
							const attrCustomizations = attributesConfig.find(item => item.oid.includes(currentAttr.OID)) ?? null;

							// Déterminer si la data d'attribut doit être [] ou SINGLE_VALUE
							const customMultiValue = attrCustomizations?.customMultiValue ?? null;
							const isMultiValue = !currentAttr.SINGLE_VALUE && (customMultiValue?.[0] !== 'SINGLE-VALUE');
							if (!isMultiValue) currentAttr.MULTI_VALUE = 'SINGLE-VALUE';

							if (attrCustomizations) {
								// Ajout des customisations de l'attribut
								if (attrCustomizations?.customWording || null)
									currentAttr.customWording = attrCustomizations.customWording;
								if (attrCustomizations?.valueCheck || null)
									currentAttr.valueCheck = attrCustomizations?.valueCheck;
							}
						});
					});
				});

//console.clear(); console.log('objectData: ', JSON.stringify(objectData, null, 2)); // Display for debug
				//		2: avec les data d'objectData de chaque attribut
				Object.keys(objectData).forEach(attrDataName => { // on parcourt les DATA
					if (attrDataName === 'dn')	return;
					const attrData = objectData[attrDataName]; // Obtenir les data pour chaque attribut

					// Parcourir chaque objectClassDetails à la recherche de l'attribut attrDataName
					objectClassesDetails.forEach(objectClass => { // rechercher dans tous les attributs de l'objectClass à enrichir
						['MUST', 'MAY'].forEach(key => {
							objectClass[key].forEach(currentAttr => {

								if (currentAttr.NAME.find(name => name.toLowerCase() === attrDataName.toLowerCase())) {
									// L'attribut trouvé peut être enrichi
									let VALUES;
									if (currentAttr.MULTI_VALUES !== 'SINGLE-VALUES') {
										VALUES = Array.isArray(attrData)
											? attrData
											: (attrData !== undefined ? [attrData] : null);
									} else {
										VALUES = Array.isArray(attrData)
											? (attrData.length > 0 ? attrData[0] : null)
											: (attrData !== undefined ? attrData : null);
									}

									if (VALUES) {
										// Enrichir le currentAttr de sa DATA
										currentAttr.VALUES = VALUES;
									}
								}
							});
						});
					});
				});
//console.clear(); console.log('EnrichObjectClassesDetails: ', JSON.stringify(objectClassesDetails, null, 2)); // Display for debug

				return res.render('edit', {dn, objectClassesDetails: objectClassesDetails, ldapSchema: ldapSchema});

			} catch(error) {
				console.error('Fiche non trouvée:', error);
				return res.status(500).send(error.message); // Renvoyer le message d'erreur
			} finally {
				// Déconnexion du client principal
				if (client) {
					try {
						await client.unbind();
					} catch(unbindError) {
						console.error('Erreur lors de la déconnexion du client:', unbindError);
					}
				}
			}
		});

		app.post('/edit/:dn', async (req, res) => {
			// Déclaration du client de connexion
			const client = ldap.createClient({ url: `${config.ldap.url}:${config.ldap.port}` });
			const dn = req.params.dn; // Assignation de dn depuis les paramètres de l'URL;
			let objectData;
			let objectClassesEdition = false;

			try {
				// Connexion au serveur LDAP
				await bindClient(client, config.ldap.data.bindDN, config.ldap.data.bindPassword);

				// Fonction parse JSON sécurisée
				const safeJSONParse = (val) => {
					try{
						return JSON.parse(val);
					} catch(error) {
						// En cas d'erreur : retourne la valeur d'origine en string pour LDAP-JS
						return (typeof val !== 'string') ?JSON.stringify(val) :val;
				}	};

//console.clear(); console.log('req.body: ', JSON.stringify(req.body, null, 2), '\n\n');	// Pour debug

				// Traitement de la réponse
				objectData = Object.keys(req.body).reduce((acc, key) => {
					// Ajout/suppression d'objectClasses
					if (key.startsWith('reload')) {
						objectClassesEdition = true;
						return acc;
					}
					if ( key.endsWith('Added') || key.endsWith('Deleted')) {
						const statusKey = key.endsWith('Deleted') ? 'DELETED' : 'ADDED';
						req.session.edit = {
							...req.session.edit,
							 [statusKey]: (req.session.edit?.[statusKey] || []).concat(req.body[key])
						};
						objectClassesEdition = true;
						return acc;
					}

					// Dédoubler les champs input dupliquées entre onglets :
					//	on retient le premier élément du getElementByName...
					let value = (key.startsWith('objectClass') || !Array.isArray(req.body[key]))
						?req.body[key]
						:req.body[key][0];

					value = Array.isArray(value) ?value.map(safeJSONParse) :safeJSONParse(value);
//console.log(key, ` : `, value); // Pour debug

					let baseKey;
					// Parse des clées multiValeurs (de valeurs Array[])
					if (key.endsWith('_multiValues')) {
						// Rétablir le nom d'attribut
						baseKey = key.substring(0, key.indexOf('_'));

						// Si la valeur est bien un tableau, parser ses valeurs
						//value = Array.isArray(value) ?value.map(safeJSONParse) :(safeJSONParse(value));
						//value = noEmpty(value);
					} else baseKey = key;

					if (Array.isArray(value)) {
						if (value.length > 0)
							acc[baseKey] = value;
					} else if (value != null && value !== '')
						acc[baseKey] = [(typeof value === 'string') ?value :JSON.stringify(value)];

					return acc;
				}, {});

//console.log('req.session.edit: ', JSON.stringify(req.session.edit, null, 2));	// Pour debug
//console.log('\n\nobjectData: ', objectData);	// Pour debug

				if (objectClassesEdition) {
					throw 255;
				} else {
					// Mise à jour de la base LDAP
					if (!objectData.objectClass.includes('top')) objectData.objectClass.push('top');
					await updateLDAP(client, dn, objectData);
				}

				// Redirection vers la page d'édition du dn
				//return res.redirect(`/edit/${dn}?errMsg=${encodeURIComponent(req.session.edit?.errMsg || '')}`);
				return res.status(200).redirect(`/newEdit/${dn}`);
				//return res.redirect(`/edit/${dn}`);
			} catch(err) {
				if (err.code === 255 || err === 255 ) {						// Poursuite de l'édition du dn
					req.session.edit = {...req.session.edit, objectData: objectData};
					return res.redirect(`/edit/${dn}?errMsg=${encodeURIComponent(req.session.edit?.errMsg || '')}`);
					//return res.redirect(`/edit/${dn}`);
				} else {
					console.error('Erreur d\'édition :', err);
					res.status(500).send({ error: err.message });
				}
			} finally {
				// Déconnexion du client LDAP
				if (client) {
					client.unbind();
				}
			}
		});

		// ***********************************************************
		// Route pour delete une entrée
		app.post('/delete/:dn', async (req, res) => {
			// Déclaration du client de connexion
			const client = ldap.createClient({ url: `${config.ldap.url}:${config.ldap.port}` });
			const dn = req.params.dn; // Assignation de dn depuis les paramètres de l'URL;

			try {
				// Connexion au serveur LDAP
				await bindClient(client, config.ldap.data.bindDN, config.ldap.data.bindPassword);

				// Validation du DN avant de supprimer
				if (!dn) {
					return res.status(400).send({ error: 'DN est requis.' });
				}

				// Suppression de l'entrée LDAP
				await new Promise((resolve, reject) => {
					client.del(dn, (err) => {
						if (err) {
							return reject(err);
						}
						resolve();
					});
				});

				// Répondre avec un message de succès
				return res.json({ message: 'Entrée supprimée avec succès.', redirect: '/search' });
			} catch(error) {
				console.error('Erreur:', error);
				return res.status(500).send({ error: 'Erreur lors de la suppression de l\'entrée LDAP : ' + error.message });
			} finally {
				// Déconnexion du client LDAP
				client.unbind();
			}
		});

		// ***********************************************************
		// Route pour valider les contrôle d'attribut édités dans la modale
		app.post('/update-attributeCtl/:dn', async (req, res) => {
			// Déclaration du client de connexion
			const client = ldap.createClient({ url: `${config.ldap.url}:${config.ldap.port}` });

			let dn = req.params.dn; // Assignation de dn depuis les paramètres de l'URL;
			let attrName = null; // Initialisation pour le nom de l'attribut
			let attrConf = {}; // Initialisation d'un objet pour stocker les configurations de l'attribut

			try {
				// Connexion au serveur LDAP
				await bindClient(client, config.ldap.data.bindDN, config.ldap.data.bindPassword);

				const rootDn = (config.configDn.attributs ?? 'ou=attribut') + ',' + config.configDn.root;

				// Récupérer les clés du corps de la requête
				const keys = Object.keys(req.body);

				for (let key of keys) {
					if (key === 'attributeId') {
						attrName = req.body[key];
					} else if (key === 'attributeType') { // MULTI-VALUES ?
						if (req.body[key] !== 'SCHEMA')
							attrConf.MULTIVALUE = (req.body[key] === 'MULTI-VALUE');
					} else if (key === 'newLabel' && req.body[key]) {
						attrConf.customWording = req.body[key];
					} else if (key === 'jsValidation' && req.body[key]) {
						attrConf.valueCheck = req.body[key];
					}
				}

				// Validation des données
				if (!attrName) {
					return res.status(400).send('Données manquantes dans \'/update-attributeCtl/:dn\'.');
				}

				const entry = {
					objectClass: ['top', 'applicationProcess'],
					cn: attrName,
					...(attrConf.customWording && { l: attrConf.customWording }),
					...(attrConf.MULTIVALUE != null && { ou: !attrConf.MULTIVALUE ? 'SINGLE-VALUE' : 'MULTI-VALUE' }),
					...(attrConf.valueCheck && { description: attrConf.valueCheck })
				};

				// Mise à jour dans la base LDAP
				await updateAPPConfig(client, 'cn=' + attrName, rootDn, entry);

				// Rafraichir des customisations d'attributs avec les nouvelles valeurs
				attributesConfig = await loadAttributesConfig(config);

				return res.redirect(`/newEdit/${dn}?errMsg=${encodeURIComponent(req.session.edit?.errMsg || '')}`);
				//return res.redirect(`/edit/${dn}`);

			} catch(error) {
				console.error('Erreur:', error);
				res.status(500).send({ message: 'Erreur lors de la mise à jour de l\'attribut', error: error.message });
			} finally {
				// Déconnexion du client LDAP
				if (client) {
					client.unbind();
			}	}
		});

		// Lancer le serveur
		app.listen(config.nodeJsPort, () => {
			console.log(`Serveur en écoute sur http://localhost:${config.nodeJsPort}`);
		});
	} catch (error) {
		logger.error('Erreur lors du chargement du schéma LDAP:', error);
		process.exit(2); // Optionnel : quittez le processus en cas d'erreur
	}
})();
root@ldap:~/frontal/ldap_search# vi views/search.ejs 
root@ldap:~/frontal/ldap_search# vi utils/ldapUtils.js 
root@ldap:~/frontal/ldap_search# vi views/search.ejs 
root@ldap:~/frontal/ldap_search# vi views/edit.ejs 
root@ldap:~/frontal/ldap_search# vi views/search.ejs 
root@ldap:~/frontal/ldap_search# vi views/edit.ejs 
root@ldap:~/frontal/ldap_search# cat views/edit.ejs 
<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Carnet d'Annuaire</title>
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
	<style>
		html, body {
			height: 100%; /* S'assure que html et body prennent toute la hauteur */
			margin: 0; /* Enlève les marges par défaut */
		}
		body {
			/* background-color: #FFFCC4; */ /* Commenté, vous avez déjà un dégradé */
			background: linear-gradient(to bottom, #fff4b2, #d1c93b); /* Dégradé du jaune clair vers un jaune plus doux */
			min-height: 100vh; /* La hauteur minimale du corps est de 100% de la fenêtre */
		}
		.form-control::placeholder {
			color: #b0b0b0; /* Couleur du placeholder (gris clair) */
			opacity: 1; /* Assurez-vous que l'opacité est à 1 */
		}
		.nav-tabs .nav-item .nav-link {
			border: 1px solid #fff4b2; /* Bordure pour tous les onglets */
			border-bottom: none; /* Enlève la bordure inférieure pour tous les onglets */
			background-color: #B19F8C; /* Fond beige pour les onglets */
			border-radius: 5px 5px 0 0; /* Arrondir uniquement le haut des onglets */
			margin-right: -1px; /* Pour éviter que les bordures se chevauchent */
			color: #000000; /* Couleur du texte en noir */
		}
		.nav-tabs .nav-item .nav-link.active {
			border: 1px solid #000000; /* Bordure noire pour l'onglet actif */
			border-bottom: none; /* Retire la bordure inférieure de l'onglet actif */
			border-right: 2px solid #000000; /* Assure que la bordure droite est visible */
			background-color: #ffffe0; /* Fond clair pour l'onglet actif */
			color: #000000; /* Couleur du texte de l'onglet actif en noir */
			padding-top: 9px; /* Ajustez selon vos besoins */
		}
		.nav-tabs .nav-item .nav-link:not(.active) { /* Cibler spécifiquement les onglets non actifs */
			background-color: #D1C6A9; /* Fond beige clair pour l'onglet non actif */
			border-bottom: 1px solid #000000; /* Ajoute une bordure inférieure noire pour les onglets non actifs */
			color: #000000; /* Couleur du texte en noir */
		}
		.tab-content {
			background-color: #ffffe0; /* Fond jaune clair pour le contenu des onglets */
			padding: 15px; /* Ajout de padding pour l'intérieur des onglets */
			border: 1px solid #000000; /* Bordure noire pour le contenu des onglets */
			border-radius: 5px; /* Coins arrondis pour le contenu des onglets */
			margin-top: -1px; /* Pour ajuster la superposition de la bordure avec les onglets */
		}
		.edit-btn {
			background: transparent;
			border: none;
			cursor: pointer;
			color: #007bff; /* Couleur du bouton d'édition */
			padding: 0; /* Supprime le padding pour un bouton plus compact */
			font-size: 0.9em; /* Réduit la taille de la police pour le bouton */
			margin-left: 5px; /* Ajoute un espacement à gauche du bouton */
		}
		.edit-btn {
			font-size: 0.8em; /* Réduit la taille de l'icône */
		}
		.btn-restore {
			background-color: #FFE0B2; /* Couleur orange plus clair */
			border: 0px solid #F5F5DC; /* Bordure d'une teinte légèrement plus foncée */
			color: black; /* Couleur du texte en noir */
		}
		.btn-restore:hover {
			background-color: #FFA726; /* Couleur plus foncée au survol */
		}
		.btn-exit {
			background-color: #FFCC80; /* Couleur orange pastel */
			border: 0px solid #F5F5DC; /* Bordure d'une teinte légèrement plus foncée */
			color: black; /* Couleur du texte en black */
		}
		.btn-exit:hover {
			background-color: #FFA726; /* Couleur plus foncée au survol */
		}
		.btn-save {
			position: relative;
			background-color: #FFFFF0; /* Couleur beige pour le bouton */
			border: 0px solid #3A6A2A; /* Bordure vert foncé pour un meilleur contraste */
			color: #000; /* Couleur du texte par défaut */
		}
		.btn-save:hover {
			background-color: #E0E0E0; /* Couleur beige plus foncé au survol */
		}
		.btn-save.disabled:hover {
			background-color: #F5F5DC; /* Rétablir la couleur d'origine lorsqu'il est désactivé */
			cursor: not-allowed; /* Change le curseur pour indiquer que le bouton est désactivé */
		}
		.btn-save.enabled {
			color: #9B111E; /* Rouge rubis lorsqu'il est activé */
			background-color: #98FB98; /* Vert tendre lorsque activé */
		}
		.modal-content {
			background-color: #ffffe0; /* Fond jaune clair pour la modale */
			border-radius: 15px; /* Arrondir les angles de la fenêtre modale */
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); /* Ajoute une ombre douce autour de la modale */
		}
		.custom-radio-group {
			display: flex;
			justify-content: space-between; /* Ecarte les boutons au maximum */
			width: 100%; /* S'assure que le conteneur prend toute la largeur disponible */
		}
		.form-check {
			flex: 1; /* Permet à chaque bouton de prendre une part égale de l'espace disponible */
			text-align: center; /* Centre le texte de chaque bouton */
		}
		.popup {
			position: absolute;
			background: white;
			border: 1px solid #ccc;
			width: 200px;
			max-height: 200px;
			overflow-y: auto;
			z-index: 1000;
			box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
		}
		.multi-values {
			flex: 1; /* Permet à l'input de remplir la largeur disponible */
			margin: 0; /* Supprime les marges pour un alignement parfait */
			/*margin-right: 5px;
			margin-left: 0px;*/
			padding: 8px; /* Espace intérieur pour un meilleur confort visuel */
			border: 1px solid #d3d3d3; /* Bordure grise */
			border-radius: 4px; /* Arrondi léger des coins */
			transition: border-color 0.3s; /* Transition douce pour les changements de couleur de bordure */
		}
		.multi-values::placeholder {
			color: #b0b0b0; /* Couleur du placeholder (gris plus clair) */
			opacity: 1; /* Assurez-vous que l'opacité est à 1 pour que la couleur soit bien visible */
		}
		.option {
			padding: 5px;
			cursor: pointer;
		}
		.option:hover, .option.selected {
			background-color: #e0e0e0; /* Couleur de surbrillance pour l'option sélectionnée */
		}
		.add-button {
			background-color: gray;
			color: white;
			border: none;
			padding: 5px 10px;
			cursor: pointer;
			border-radius: 5px;
		}
		.btn-delete {
			background-color: #dc3545; /* Rouge pour indiquer une action de suppression */
			color: white; /* Texte en blanc pour un bon contraste */
			border: none; /* Retirer la bordure par défaut */
			padding: 10px 15px; /* Espacement interne */
			cursor: pointer; /* Changer le curseur pour indiquer que c'est cliquable */
			border-radius: 5px; /* Coins arrondis */
			transition: background-color 0.3s; /* Animation de changement de couleur */
		}
		.btn-delete:hover {
			background-color: #c82333; /* Couleur plus foncée au survol */
		}
		.objectClassesContainer {
			display: flex; /* Utilisation de flexbox pour la mise en page */
			justify-content: space-between; /* Espace entre les colonnes */
			align-items: stretch; /* Alignement en haut des colonnes */
			height: calc(70vh - 100px); /* Hauteur fixe pour le conteneur */
		}
		.fixed-header {
			position: sticky; /* Rendre la position fixe quand on fait défiler */
			top: 0; /* Positionner en haut */
			background-color: #ffffe0; /* Fond blanc pour le titre */
			z-index: 10; /* Assurez-vous que le titre soit au-dessus du contenu */
			padding: 10px; /* Ajoute un peu de rembourrage */
			border-bottom: 1px solid #ccc; /* Optionnel : une bordure pour séparer du contenu */
		}
		.header-row {
			display: flex; /* Utiliser flexbox pour aligner les éléments en ligne */
			align-items: center; /* Centrer verticalement les éléments */
		}
		.header-row h4 {
			margin-right: 10px; /* Ajouter un peu d'espace entre le titre et le label */
		}
		.attribute-liste {
			margin-left: auto; /* Pousse cet élément vers la droite */
			text-align: right; /* Assurez-vous que le texte est aligné à droite */
		}
		.list {
			flex: 1; /* Permet aux listes de prendre une part égale de l'espace */
			overflow-y: auto; /* Activer le défilement si le contenu déborde */
			border: 1px solid #ccc; /* Bordure pour les listes */
			border-radius: 4px; /* Coins arrondis pour les listes */
			padding: 10px; /* Rembourrage intérieur */
			margin-top: 10px; /* Espace au-dessus des listes */
		}
		.list-item {
			margin: 5px 0;
			cursor: pointer;
			padding: 5px;
		}
		.list-item:hover {
			background-color: #f0f0f0;
		}
		.highlight {
			background-color: #ffeb3b; /* Couleur de surbrillance */
		}
		.placeholder {
			color: #888; /* Couleur grisée pour les messages d'instruction */
			font-style: italic; /* Italique pour le style */
			text-align: center; /* Centrer le texte */
			margin-top: 10px; /* Espace au-dessus du message */
		}
		.attributeList {
			position: sticky; /* L'élément reste fixe dans la fenêtre */
			top: 10px; /* Distance depuis le haut de la fenêtre */
			right: 20px; /* Distance depuis le bord droit de la fenêtre */
			width: 48%;
			max-height: 80vh; /* Hauteur maximale pour le défilement */
			overflow-y: auto; /* Activer le défilement si le contenu déborde */
			border: 1px solid #ccc;
			border-radius: 4px;
			padding: 10px;
			z-index: 10; /* Assurez-vous que l'élément est au-dessus des autres éléments */
		}
		.objectClassesCheckbox {
			margin-right: 10px; /* Ajustez la valeur pour plus ou moins d'espace */
		}
		h4 {
			margin: 0; /* Réinitialiser la marge */
			padding: 10px; /* Ajouter un peu de rembourrage pour le style */
			background-color: #fffacd; /* Couleur de fond pour les titres (jaune un peu plus foncé) */
			border-bottom: 1px solid #ccc; /* Bordure pour séparer le titre du contenu */
		}
		.blinking {
			animation: blink-animation 1s steps(5, start) infinite;
		}
		@keyframes blink-animation { /* Définition de l'animation */
			to {
				visibility: hidden; /* Cache l'élément à la fin de l'animation */
			}
		}
	</style>
</head>
<body>
	<div class="container mt-5 position-relative">
		<div style="display: flex;justify-content: space-between;align-items: center;padding: 10px;">
			<h1 title="LDAP Editor" style="margin: 0;">Carnet d'Annuaire</h1> <strong><span id="error" class="blinking" style="color: red;"></span></strong>
		</div>

		<!-- Formulaire principal -->
		<form id="mainForm" action="/edit/<%= dn %>" method="POST">

			<!-- Conteneur pour les boutons avec Flexbox -->
			<div class="d-flex justify-content-between mb-3">
				<div class="d-flex"> <!-- Boutons à gauche -->
					<button type="submit" id="saveButton" class="btn btn-save" style="width: 120px;" disabled>Valider</button>
					<button type="button" id="restoreButton" class="btn btn-restore" onclick="restoreValues()">Restaurer les valeurs</button>
					<button type="button" id="exitButton" class="btn btn-exit ml-2" style="width: 120px;" onclick="exit()">Retour</button>
				</div>

				<div class="d-flex"> <!-- Boutons à droite -->
					<button type="button" id="deleteButton" class="btn btn-delete ml-2" title='La totalité de cette entrée sera supprimée ...' onclick="deleteEntry()">Supprimer</button>
				</div>
			</div>

			<!-- Nav tabs -->
			<ul class="nav nav-tabs" id="myTab" role="tablist">
				<% objectClassesDetails.forEach((objectClass, objectClassIndex) => {
						const objName = objectClass.NAME[0];
						const description = objectClass.DESC ?? 'No description available';
					%>
					<li class="nav-item" title="<%= description %>">
						<a class="nav-link <%= objectClassIndex === 0 ? 'active' : '' %>"
							id="<%= objName %>-tab"
							data-toggle="tab"
							href="#<%= objName %>"
							role="tab"
							aria-controls="<%= objName %>"
							aria-selected="<%= objectClassIndex === 0 %>">
								<%= objName %>
							</a>
					</li>
				<% }) %>
				<li class="nav-item">
					<a class="nav-link" id="add-tab" data-toggle="tab" href="#add" role="tab" aria-controls="add" aria-selected="false" title="Add/remove objectClasses">+</a>
				</li>
			</ul>

			<!-- Tab panes -->
			<div class="tab-content" id="myTabContent">
				<% objectClassesDetails.forEach((objectClass, objectClassIndex) => {
					const objName = objectClass.NAME[0];
				%>
					<div class="tab-pane fade <%= objectClassIndex === 0 ? 'show active' : '' %>" id="<%= objName %>" role="tabpanel" aria-labelledby="<%= objName %>-tab">
						<input type="hidden" name="objectClass" value="<%= objName %>"/>
						<% ['MUST', 'MAY'].forEach(TYPE => { %>
							<h3 class="underline">Attributs <%= (TYPE === 'MUST' ?'obligatoires' :'optionnels') %> :</h3>
							<ul>
								<% objectClass[TYPE].forEach(currentAttr => {
									const attrName = currentAttr.NAME[0];
									const description = currentAttr.DESC ?? 'No description available';
								%>
								<li>
									<strong title="<%= description %>"><%= currentAttr.customWording || attrName %>:</strong>
									<button type="button" class="edit-btn" title="Edition des propriétés d'attributs" data-object-class-index='<%= objectClassIndex %>' onclick="openEditModal(this, '<%= attrName %>')">
										<i class="fas fa-pencil-alt"></i>
									</button>
										<!-- popupMultiValues -->
										<input type="text"
											name="<%= attrName %>"
											data-object-class-index = '<%= objectClassIndex %>'
											placeholder="Éditez ici les valeurs de l'attribut '<%= attrName %>'"
											oninput="checkInputFunction(this);"
											<% if (currentAttr.MULTI_VALUE === 'SINGLE-VALUE') { %>
												class="form-control field"
												value="<%= (Array.isArray(currentAttr.VALUES) ?currentAttr.VALUES[0] :currentAttr.VALUES) ?? '' %>"
											<% } else { %>
												class="multi-values form-control field"
												value="<%= JSON.stringify(Array.isArray(currentAttr.VALUES) ?currentAttr.VALUES :(currentAttr.VALUES != null ?[currentAttr.VALUES] :[])) %>"
											<% } %>
										/>
								</li>
								<% }) %>
							</ul>
						<% }) %>
					</div>
				<% }) %>

				<!-- Tab pour ajouter une nouvelle objectClass -->
				<div class="tab-pane fade" id="add" role="tabpanel" aria-labelledby="add-tab">
					<div class="sub-tabs">
						 <ul class="nav nav-tabs" id="subTab" role="tablist">
							 <li class="nav-item">
								 <a class="nav-link active" id="structural-tab" data-toggle="tab" href="#structural" role="tab" aria-controls="structural" aria-selected="true">ObjectClasses STRUCTURAL</a>
							 </li>
							 <li class="nav-item">
								 <a class="nav-link" id="auxiliary-tab" data-toggle="tab" href="#auxiliary" role="tab" aria-controls="auxiliary" aria-selected="false">ObjectClasses AUXILIARY</a>
							 </li>
						 </ul>

						 <!-- Contenu des sous-onglets -->
						 <div class="tab-content" id="subTabContent">
							 <div class="tab-pane fade show active" id="structural" role="tabpanel" aria-labelledby="structural-tab">
								 <div class="fixed-header">
									 <div class="header-row">
										 <h4>STRUCTURAL ObjectClasses</h4>
										 <h4 class="attribute-liste" name='attributeHeaders'>Attributs:</h4>
									 </div>
								 </div>
								 <div class="objectClassesContainer">
									 <div class="list" name="objectClassList">
										 <!-- La liste des objectClasses STRUCTURAL sera générée ici -->
									 </div>
									 <div class="list attributeList" name="attributeList">
										 <div id="attributePlaceholderStructural" name="placeHolder">
											 Cliquer sur un objectClass pour afficher les attributs ...
										 </div>
										 <!-- La liste des attributs sera affichée ici -->
									 </div>
								 </div>
							 </div>
							 <div class="tab-pane fade" id="auxiliary" role="tabpanel" aria-labelledby="auxiliary-tab">
								 <div class="fixed-header">
									 <div class="header-row">
										 <h4>AUXILIARY ObjectClasses</h4>
										 <h4 class="attribute-liste" name='attributeHeaders'>Attributs:</h4>
									 </div>
								 <div class="objectClassesContainer">
									 <div class="list" name="objectClassList">
										 <!-- La liste des objectClasses AUXILIARY sera générée ici -->
									 </div>
									 <div class="list attributeList" name="attributeList">
										 <div id="attributePlaceholderAuxiliary" name="placeHolder">
											 Cliquer sur un objectClass pour afficher les attributs ...
										 </div>
										 <!-- La liste des attributs sera affichée ici -->
									 </div>
								 </div>
							 </div>
						 </div>
					 </div>
				</div>
			</div>
		</form>

		<!-- Modale pour l'édition d'attributs -->
		<div class="modal fade" id="editModal" tabindex="-1" role="dialog" aria-labelledby="editModalLabel" aria-hidden="true">
			<div class="modal-dialog" role="document">
				<div class="modal-content">
					<form id="attrForm" action="/update-attributeCtl/<%= dn %>" method="POST">
						<div class="modal-header">
							<h5 class="modal-title" id="editModalLabel"><strong>Modifier le libellé d'attribut "<span id="attributeName"></span>"</strong></h5>
							<button type="button" class="close" data-dismiss="modal" aria-label="Fermer">
								<span aria-hidden="true">&times;</span>
							</button>
						</div>
						<div class="modal-body">
							<div class="form-group">
								<label for="newLabel"><strong>Libellé d'affichage de l'attribut :</strong></label>
								<input type="text" class="form-control" id="newLabel" name="newLabel" style='color:black;'>
							</div>
							<!-- Ajout des boutons radio -->
							<div class="form-group">
								<label><strong>Type d'attribut :</strong></label><br>
								<div class="custom-radio-group"> <!-- Container flex pour les boutons radio -->
									<div class="form-check">
										<input class="form-check-input" type="radio" name="attributeType" id="singleValue" value="SINGLE-VALUE">
										<label class="form-check-label" for="singleValue">SINGLE-VALUE</label>
									</div>
									<div class="form-check" hidden>
										<input class="form-check-input" type="radio" name="attributeType" id="schema" value="SCHEMA" disabled>
										<label class="form-check-label" for="schema">SCHEMA</label>
									</div>
									<div class="form-check">
										<input class="form-check-input" type="radio" name="attributeType" id="multiValue" value="MULTI-VALUE" checked>
										<label class="form-check-label" for="schema">MULTI-VALUES</label>
									</div>
								</div>
							</div>
							<div class="form-group">
								<label for="jsValidation"><strong>Code JS de contrôle de saisie :</strong></label>
								<textarea class="form-control" id="jsValidation" name="jsValidation" rows="10" placeholder="Saisissez le code JavaScript ici..."></textarea>
							</div>
							<input type="hidden" id="attributeId" name="attributeId"> <!-- Champ caché pour l'attributeName -->
						</div>
						<div class="modal-footer d-flex justify-content-between">
							<div>
								<button type="button" class="btn btn-light btn-sm" onclick="changeModalSize(false)" style="background-color: #ffffe0; border: none;"> &gt;&lt; </button>
								<button type="button" class="btn btn-light btn-sm" onclick="changeModalSize(true)" style="background-color: #ffffe0; border: none;"> &lt;&gt; </button>
							</div>
							<div>
								<button type="button" class="btn btn-secondary" data-dismiss="modal">Annuler</button>
								<button type="button" class="btn btn-primary" id="validerModale" onclick="submitModal(this)">Valider</button>
							</div>
						</div>
					</form>
				</div>
			</div>
		</div>

		<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
		<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
		<script src="/js/popupMultiValues.js"></script>
		<script>
const urlParams = new URLSearchParams(window.location.search);
const errMsg = urlParams.get('errMsg');
const objectClassesDetails = <%- JSON.stringify(objectClassesDetails) %>;
const ldapSchema = <%- JSON.stringify(ldapSchema) %>;
let reloadRequest = false;

function init() {
	// Hidden des onglets DELETED
	objectClassesDetails.forEach(objectClass => {
		if (!!objectClass.DELETED) {
			document.getElementById(objectClass.NAME[0] + '-tab').style.display="none"; // Cacher l'onglet
			document.getElementById(objectClass.NAME[0]).style.display="none"; // Cacher le contenu de l'onglet
		}
	});

	// Ajout de l'event contrôle de la dernière mise à jour éventuelle depuis le check() attribut
	document.querySelectorAll('input.field').forEach(input => {
		input.addEventListener('changed', function() {
			synchronize(input); // 'this' doit faire référence à l'élément input
		});
	});

	checkSaveButton();

	// Affichage d'un eventuel message transmis du serveur
	if (errMsg)	document.getElementById('error').textContent = errMsg;
}

function synchronize(input) {	// des différents champs/onglets pour l'attribut
	// Mise à jour des values des chamos multi-values éventuellement modifiés par le check() des propriétés d'attribut
	if (input.classList.contains('multi-values')) {
		if (input.value.length) {
			let options = JSON.parse(input.getAttribute('data-values'));
			options[input.getAttribute('data-index')] = input.value;
			input.setAttribute('data-values', JSON.stringify(options));
	}	}

	// Mise à jour de l'attribut dans les autres onglets
	const allTabs = document.querySelectorAll('.tab-pane'); // Sélectionner tous les onglets
	allTabs.forEach(tab => {
		tab.querySelectorAll(`input[name="${input.name}"]`).forEach(field => {
			field.value = input.value;
			if (field.classList.contains('multi-values'))
				field.setAttribute('data-values', input.getAttribute('data-values'));
		});
	});

	// Mise à jour de l'état du bouton de Validaion
	checkSaveButton();
}

function checkInputFunction(input) {
	if (!(input instanceof HTMLInputElement)) {
		console.error('L\'argument passé à checkInputFunction n\'est pas un élément input valide.');
		return;
	}

	let attrName = input.name;
	if (attrName?.length) {
		const objectClassIndex = parseInt(input.dataset.objectClassIndex);
		const objectClass = objectClassesDetails[objectClassIndex];
		const objectAttribute = objectClass.MUST?.find(attr => attr.NAME.includes(attrName))
				|| objectClass.MAY?.find(attr => attr.NAME.includes(attrName));

		// Excution des scripts personnailisés sur la valeur en cours de saisie
		if (objectAttribute.valueCheck) {
			// Transmettre l'input de saisie ( ->id(name) ) pour les champs multi-values :
			const defaultValue = input.classList.contains('multi-values')
				?(safeJSONParse(input.getAttribute('data-default-values'))[input.getAttribute('data-index')] || '[]')
				:input.defaultValue;
			const currentValue = input.classList.contains('multi-values')
				?(safeJSONParse(input.getAttribute('data-values'))[input.getAttribute('data-index')] || '[]')
				:input.value;

			try { // lancement du script
				eval (objectAttribute.valueCheck);
				check (input, objectClassesDetails, defaultValue, currentValue);

			} catch (error) {
				// Envoi du message d'erreur éventuel vers le client
				document.getElementById('error').textContent = 'Erreur de définition dans la fonction check() ...';
				setTimeout(() => {document.getElementById('error').textContent = '';}, 500);
			}
		}
		synchronize(input);
	}
}

// Rafraichir la page et se repositionner sur l'onglet courant
function restoreValues() {
	if (isDataChanged()) {
		if (!confirm("Des modifications sont en cours : êtes-vous sûr de vouloir les abandonner ?"))
			return;
	} else return;

	// Rafraichir la page
	saveCurrentTab();
	window.location.href = '/newEdit/<%= dn %>';
}

// Abandon de la page
function exit() {
	if (isDataChanged()
		&& !confirm("Des modifications sont en cours : êtes-vous sûr de vouloir quitter ?") )
			return;

	window.location.href = '/search'; // Redirection vers la route '/search'
}

async function deleteEntry() {
	if (confirm("Êtes-vous sûr de vouloir supprimer cette entrée ?")) {

		// Logique de suppression de l'entrée dn
		try {
			const response = await fetch("/delete/<%= dn %>", {
				method: 'POST',
					headers: {
					'Content-Type': 'application/json'
					}
			});

			const data = await response.json();

			if (response.ok) {
				alert(data.message); // Message de succès
				window.location.href = data.redirect; // Redirection vers /search
			} else {
				alert(`Erreur: ${data.error}`);
			}
		} catch (error) {
			console.error('Erreur:', error);
			alert('Erreur lors de la suppression de l\'élément.');
		}
	}
}

// Edition des propriétés d'attribut
function openEditModal(button, attrName) {
	const objectClassIndex = parseInt(button.dataset.objectClassIndex);
	const objectClass = objectClassesDetails[objectClassIndex];
	const objectAttribute = objectClass.MUST?.find(attr => attr.NAME.includes(attrName))
		|| objectClass.MAY?.find(attr => attr.NAME.includes(attrName));
	document.getElementById('validerModale').dataset.objectClassIndex = objectClassIndex;
	if (isDataChanged()) {
		alert("Opération impossible : il y a des modifications d'attributs en cours !");
		return;
	}

	// Label d'attribut
	const newLabelInputField = document.getElementById('newLabel');
	newLabelInputField.value = objectAttribute.customWording || '';
	newLabelInputField.placeholder = attrName;

	// Bontons radio SINGLE-VALUE/MULTI-VALUES:
	//	- OpenLDAP schema : not SINGLE-VALUE -> MULTI-VALUES,
	//	- this appli: can force SINGLE-VALUE.
	const radio = !!objectAttribute?.SINGLE_VALUE
			? 'singleValue'
			:(objectAttribute.MULTI_VALUE == null && objectAttribute.MULTI_VALUE !== 'SINGLE-VALUE')
				?'multiValue' :'singleValue';
	document.getElementById('multiValue').disabled = objectAttribute.SINGLE_VALUE;
	document.getElementById(radio).checked = true;
	document.getElementById('schema').disabled = true;

	// Script de vérification des saisies
	document.getElementById('jsValidation').value = objectAttribute.valueCheck || '';

	document.getElementById('attributeName').textContent = attrName;
	document.getElementById('attributeId').value = objectAttribute.OID; // Pour envoi par le formulaire lors de la soumission

	saveCurrentTab();
	$('#editModal').modal('show');
}


function submitModal(submitButton) {
	const attrName = document.getElementById('newLabel').placeholder;
	const multiValue = document.getElementById('multiValue').checked;
	const objectClassIndex = parseInt(submitButton.dataset.objectClassIndex);
	const objectClass = objectClassesDetails[objectClassIndex];
	const objectAttribute = objectClass.MUST?.find(attr => attr.NAME.includes(attrName))
		|| objectClass.MAY?.find(attr => attr.NAME.includes(attrName));
	const singleValue = !!objectAttribute.SINGLE_VALUE;
	if (singleValue || (!singleValue && multiValue))
		document.getElementById('schema').checked = !(document.getElementById('schema').disabled = false);
	document.getElementById('attrForm').submit();
}

function changeModalSize(increase) {
	const modalDialog = document.querySelector('#editModal .modal-dialog');
	const currentClassList = modalDialog.classList;
	const jsValidationTextarea = document.getElementById('jsValidation');
	const greater = document.querySelector('.btn-light.btn-sm[onclick="changeModalSize(true)"]');
	const lower = document.querySelector('.btn-light.btn-sm[onclick="changeModalSize(false)"]');

	let currentSize = '';
	if (currentClassList.contains('modal-sm')) {
		currentSize = 'sm';
	} else if (currentClassList.contains('modal-lg')) {
		currentSize = 'lg';
	} else if (currentClassList.contains('modal-xl')) {
		currentSize = 'xl';
	}

	lower.style.color = greater.style.color = 'black';
	if (increase) {
		if (currentSize === 'sm') {
			currentClassList.remove('modal-sm');
			jsValidationTextarea.rows = 10;
		} else if (currentSize === '') {
			currentClassList.remove('modal-sm');
			currentClassList.add('modal-lg');
			jsValidationTextarea.rows = 15;
		} else if (currentSize === 'lg') {
			currentClassList.remove('modal-lg');
			currentClassList.add('modal-xl');
			jsValidationTextarea.rows = 20;
			greater.style.color = '#ffffe0';
			greater.blur();
		}
	} else {
		if (currentSize === 'xl') {
			currentClassList.remove('modal-xl');
			currentClassList.add('modal-lg');
			jsValidationTextarea.rows = 15;
		} else if (currentSize === 'lg') {
			currentClassList.remove('modal-lg');
			jsValidationTextarea.rows = 10;
		} else if (currentSize === '') {
			currentClassList.remove('modal-lg');
			currentClassList.add('modal-sm');
			jsValidationTextarea.rows = 5;
			lower.style.color = '#ffffe0';
			lower.blur();
		}
	}
}

function safeJSONParse(val) {
	try{return JSON.parse(val);
	} catch(error) {
		// En cas d'erreur : retourne la valeur d'origine en string pour LDAP-JS
		return (typeof val !== 'string') ?JSON.stringify(val) :val;
}	}

function arraysEqualWithDuplicates(arr1, arr2) {
	if (arr1.length !== arr2.length)			return false;
	const arr2Copy = [...arr2]; // Copie de arr2
	for (let item of arr1) {
		const index = arr2Copy.indexOf(item);
		if (index === -1)						return false;
			arr2Copy.splice(index, 1); // Supprime l'élément à l'index trouvé
	}
	// Si arr2Copy est vide après le parcours de arr1, les tableaux sont égaux
	return arr2Copy.length === 0;
}

// Valide le bouton 'saveButton' seulement sur modification d'attributs
function isDataChanged() {
	// Sélectionne tous les inputs de type text et multi-values dans .tab-pane
	const inputs = document.querySelectorAll('.tab-pane input.field[type="text"]');
	const inputMap = {}; // Object pour stocker les inputs non clonés
	inputs.forEach(input => {
		if (input.name) inputMap[input.name] = input; // Garantir l'unicité des input.name traités
	});

	// Vérifier les changements attribut par attribut dans le masque
	const hasChanged = Object.values(inputMap).some(input => {
		const defaultValue = input.classList.contains('multi-values')
			?safeJSONParse(input.getAttribute('data-default-values') || '[]')
			:input.value;
		const currentValue = input.classList.contains('multi-values')
			?safeJSONParse(input.getAttribute('data-values') || '[]')
			:input.defaultValue;
		return !arraysEqualWithDuplicates(defaultValue, currentValue);
	});

	// Vérifiez également s'il y a modification dans les objetsClasses
	const objClsModified = objectClassesDetails.some(item =>
		(!!item.DELETED && !item.ADDED) || (!!item.ADDED && !item.DELETED)
	);

	return hasChanged || objClsModified; // Retourne true si des changements ont été détectés
}

function areAllMUSTAttributesFilled() {
	const allMUSTAttributeNames = [...new Set(objectClassesDetails.flatMap(objectClass => 
		objectClass.MUST.map(attr => attr.NAME[0])
	))];

	return allMUSTAttributeNames.every(name => {
		const input = document.getElementsByName(name)[0];
		return (input.classList.contains('multi-values') ?safeJSONParse(input.getAttribute('data-values') || '[]') :input.value.trim()).length > 0;
	});
}

function checkSaveButton() {
	const allMUSTAttributesFilled = areAllMUSTAttributesFilled();
	const dataChanged = isDataChanged();
	const isButtonEnabled = allMUSTAttributesFilled && dataChanged;

	// Mise à jour de l'état du bouton 'saveButton'
	const saveButton = document.getElementById('saveButton');
	saveButton.title = allMUSTAttributesFilled ?(dataChanged ?'Des données ont été modifiées !' :'Aucune donnée n\'a encore été modifiée ...') :'Certains attributs obligatoires sont manquants !...';

	saveButton.disabled = !isButtonEnabled;
	saveButton.classList.toggle('enabled', isButtonEnabled);
	saveButton.classList.toggle('disabled', !isButtonEnabled);

	// Mise à jour de l'état du bouton 'restoreButton'
	const restoreButton = document.getElementById('restoreButton');
	restoreButton.title = dataChanged ?'Attention : certaines données ont été modifiées !' :'Aucune donnée n\'a encore été modifiée.';

	// Mise à jour de l'état du bouton 'restoreButton'
	const exitButton = document.getElementById('exitButton');
	exitButton.title = dataChanged ?'Attention : les modifications en cours seront perdues !' :'Retour à la recherche ...';
}

function objectClassesEdit(checkbox, objectClassName) {
	const tabContainer = document.querySelector('#myTab');
	const addTab = document.querySelector('#add-tab');

	// Sélectionner l'onglet correspondant à l'objectClass
	const tabLink = document.getElementById(objectClassName + '-tab');
	const tabPane = document.getElementById(objectClassName);

	let msg = 'Êtes-vous sûr de vouloir ' + (checkbox.checked ? 'ajouter' : 'supprimé')
		+ ' cet objetClass ' + (checkbox.checked ?'au' :'du') + ' DN en cours d\'édition ?'
		+ (checkbox.checked ?'' :'\n(certaines données seront probablement perdues ...)');

	if (checkbox.checked) {
		if (tabLink) {
			const objectClass = objectClassesDetails.find(item => item.NAME.includes(objectClassName)); 
			if (objectClass) delete objectClass.DELETED; // Positionner la propriété DELETED

			tabLink.style.display = "";	// Assurez-vous que l'onglet est visible
			tabPane.style.display = "";	// Assurez-vous que le contenu de l'onglet est visible
		} else {
			if (!confirm(msg)) {
				checkbox.checked = false;
				return;
			}
			objectClassesDetails.push({
				NAME: [objectClassName],
				ADD: true
			});

			// Submit() interceptable de mainForm
			reloadRequest = true;	// To allow the new attributes to be entered
			saveCurrentTab();
			document.getElementById('mainForm').dispatchEvent(new Event('submit', { cancelable: true })); // Déclenche l'événement de soumission 
		}
	} else {
		if (tabLink) {
			if (confirm(msg)) {
				// Supprimer l'onglet
				//tabPane.remove();
				tabLink.style.display = "none";	// Cacher l'onglet
 				tabPane.style.display = "none";	// Cacher le contenu de l'onglet

				// Marquer l'objectClass DELETED
				const objectClass = objectClassesDetails.find(item => item.NAME.includes(objectClassName)); 
				if (!!objectClass)
					objectClass.DELETED = true; // Positionner la propriété DELETED
			} else {
				checkbox.checked = true;
			}
		}
	}
	checkSaveButton();
}

function removeHiddenTabs() {
	// MArquer les inputs multi-values
	const inputs = document.getElementById('mainForm').querySelectorAll('input.multi-values');
	if (inputs.length>0) {
		Array.from(inputs).forEach(input => {
			if (document.getElementById(input.name)) input.name += "_multiValues";
		});
	}

	if (reloadRequest) { // Juste rafraichir la page pour l'affichage du new objectClass
		// Marquer les objectClasses ADDED/DELETED dans l'envoi du formulaire
		objectClassesDetails.forEach(objectClass => {
			if (!!objectClass.DELETED || !!objectClass.ADD) {
				const item = document.createElement('input');
				item.name = !!objectClass.DELETED ?'objectClass_Deleted' :'objectClass_Added';
				item.value = objectClass.NAME[0];
				item.type = 'hidden';
				mainForm.appendChild(item);
			}
		});
		
		// Marquer le formulaire pour un simple reload
		const item = document.createElement('input');
		item.name = 'reload';
		item.type = 'checkbox';
		item.hidden = true;
		item.checked = true;	// Passer l'info au formulaire
		mainForm.appendChild(item);
	} else { // Remove all hidden tabs before base update
		objectClassesDetails.forEach(objectClass => {
			if (!!objectClass.DELETED) {
				document.getElementById(objectClass.NAME[0] + '-tab').remove();
				document.getElementById(objectClass.NAME[0]).remove();
			}
		});

		// Mettre à jour les input.value des champs multi-values
		document.querySelectorAll('input.multi-values').forEach(input => {
			input.value = input.getAttribute('data-values');
		});
	}
}

// Gestion de la soumission du formulaire mainForm
const mainForn = document.getElementById('mainForm');
mainForn.addEventListener('submit', (event) => {
	removeHiddenTabs(); // Elimination des objectClasses deleted (onglets hidden)
	saveCurrentTab();
	mainForn.submit();
});
mainForm.addEventListener('keydown', (event) => {
	// Récupérer l'élément actif
	const activeElement = document.activeElement;

	// Vérifier si la touche pressée est 'Enter' et que le focus est sur le formulaire lui-même
	if (event.key === 'Enter' && !['TEXTAREA'].includes(activeElement.tagName)) {
		event.preventDefault(); // Empêche la soumission du formulaire
	}
});

// Sauvegarder la position de l'onglet courant
function saveCurrentTab(){
	let activeTab;
	['myTab', 'add'].forEach(tabsId => {
		activeTab = document.getElementById(tabsId).querySelector('.nav-link.active');
		if (activeTab && activeTab.id) localStorage.setItem(tabsId === 'myTab' ?'activeObjectClassTab' :'activeObjectClassAddTab', activeTab.id);
	});
}

// Retablir la position sur le tab ADD/REMOVE objectClasses
document.getElementById('add-tab').addEventListener('click', function(event) {
	let activeTabId = localStorage.getItem('activeObjectClassAddTab');
	if (!activeTabId) {
		activeTabId = document.getElementById('add').querySelectorAll('.nav-link')[0].id;
		document.getElementById(activeTabId).click();
	}
});
// Ajout des gestionnaires d'événements pour ses deux sous-onglets
document.querySelectorAll('#add .nav-link').forEach(link => {
	link.addEventListener('click', function(event) {
		saveCurrentTab(); // Appelle la fonction pour sauvegarder l'onglet actif
	});
});

// Fonction pour restaurer la position sur l'onglet actif après le rechargement page
window.onload = function() {
	const activeTabId = localStorage.getItem('activeObjectClassTab')
		|| document.getElementById('myTab').querySelectorAll('.nav-link')[0].id;
	document.getElementById(activeTabId).click(); // Simule le clic sur l'onglet actif
};

// AFFICHAGE de l'onglet "+"
const objectClassLists = Array.from(document.getElementsByName('objectClassList'));
const attributeLists = Array.from(document.getElementsByName('attributeList'));
const attributePlaceholders = Array.from(document.getElementsByName('placeHolder'));
const attributeHeaders = Array.from(document.getElementsByName('attributeHeaders'));

// Assurez-vous que les sélections sont valides
if (objectClassLists.length < 2 || attributeLists.length < 2 || attributePlaceholders.length < 2) {
	console.error('Schéma HTML insuffisant pour lister les objectClasses et les attributs.');
} else {
	// Créer un tableau des types d'objectClasses
	const objectClassTypes = [
		{ type: 'STRUCTURAL', objectClassList: objectClassLists[0], attributeList: attributeLists[0], attributePlaceholder: attributePlaceholders[0], attributeHeaders: attributeHeaders[0] },
		{ type: 'AUXILIARY', objectClassList: objectClassLists[1], attributeList: attributeLists[1], attributePlaceholder: attributePlaceholders[1], attributeHeaders: attributeHeaders[1] }
	];

	// Remplir la liste des objectClasses
	ldapSchema.objectClasses.forEach((objectClass) => {
		const objectClassInfo = objectClassTypes.find(cls => cls.type === objectClass.TYPE);
		
		// Vérifier si le type d'objectClass est trouvé
		if (!objectClassInfo) return;

		const { objectClassList, attributeList, attributePlaceholder, attributeHeaders } = objectClassInfo;

		// Créer un élément de la liste des objectClasses
		const listItem = document.createElement('div');
		listItem.className = 'list-item';

		// Vérifier si l'objectClass est présent dans objectClassesDetails
		const isChecked = objectClass && 
			objectClassesDetails.some(detail => 
				detail.NAME.includes(objectClass.NAME[0]) && !detail.DELETED
			);

		// Créer la case à cocher
		const checkbox = document.createElement('input');
		checkbox.type = 'checkbox';
		checkbox.className = 'checkbox objectClassesCheckbox';
		checkbox.checked = isChecked;

		// Ajouter la case à cocher et le nom de l'ObjectClass dans l'élément de liste
		listItem.appendChild(checkbox);
		listItem.appendChild(document.createTextNode(objectClass.NAME[0]));
		listItem.title = objectClass.DESC || "Pas de description disponible";

		// Événement de clic pour gérer l'état de la case à cocher
		checkbox.addEventListener('click', function(event) {
			event.stopPropagation(); // Empêche la propagation du clic pour ne pas déclencher la surbrillance
			objectClassesEdit(checkbox, objectClass.NAME[0]);
		});

		// Événement de clic pour mettre en surbrillance l'objectClass et afficher les attributs
		listItem.addEventListener('click', function() {
			// Vérifiez si l'item est déjà surligné
			const isHighlighted = listItem.classList.toggle('highlight');

			// Supprimer la surbrillance des autres éléments
			Array.from(objectClassList.getElementsByClassName('highlight')).forEach(item => {
				if (item !== listItem) {
					item.classList.remove('highlight');
				}
			});

			// Remplir la liste des attributs si l'item est surligné
			if (isHighlighted) {
				fillAttributeList(objectClass, attributeList, attributePlaceholder, attributeHeaders);
			} else {
				attributeHeaders.innerHTML = `Attributs':`;
				attributePlaceholder.innerText = 'Cliquer sur un objectClass pour afficher ses attributs ...';
				attributeList.innerHTML = ''; // Vider la liste des attributs
				attributeList.appendChild(attributePlaceholder); // Réafficher le placeholder
			}
		});
		objectClassList.appendChild(listItem);
	});
}

// Fonction pour remplir la liste des attributs
function fillAttributeList(objectClass, attributeList, attributePlaceholder, attributeHeaders) {
	let hasAttributes = false;

	// Vider la liste des attributs
	attributeList.innerHTML = '';
	attributeList.appendChild(attributePlaceholder);

	// Ajouter les attributs MUST et MAY correspondants
	['MUST', 'MAY'].forEach(key => {
		if (objectClass[key]) {
			objectClass[key].forEach(attrName => {
				const attrItem = document.createElement('div');
				const attribute = ldapSchema.attributes.find(attr => attr.NAME.includes(attrName));
				attrItem.className = 'list-item';
				attrItem.innerText = `${attrName} (${key})`; // Le nom de l'attribut
				attrItem.title = attribute?.DESC || 'Aucune description disponible.';
				attributeList.appendChild(attrItem);
				hasAttributes = true; // Indiquer qu'il y a des attributs
			});
			// Mettre à jour l'en-tête
			attributeHeaders.innerHTML = `Attributs de '<strong>${objectClass.NAME[0]}</strong>':`;
		}
	});
	
	// Mettre à jour le placeholder
	attributePlaceholder.innerText = hasAttributes ? '' : 'Aucun attribut pour cet objectClass.';
}

// Appel de la fonction pour init à la fin du chargement du DOM
document.addEventListener('DOMContentLoaded', init);
		</script>
	</div>
</body>
</html>
